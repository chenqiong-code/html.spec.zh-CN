# 1 介绍
## 1.1 这个规范适用于哪里？

这个规范非常详细的定义了web平台的一部分内容，它与定义web平台的其它规范的关系可以用下面这张图片进行总结，它们一起完整的定义了web平台的规范。

![position](/1.png)

## 1.2 这是HTML5吗？

狭义的观点：是

更详细的回答：这个术语HTML5是作为一个流行词被广泛的使用，指的是现代web技术，现代web技术中的大部分是由WHATWG规范化的。这个文档只是WHATWG规范之一；其他的可以从[WHATWG规范概述](https://spec.whatwg.org/)获得

## 1.3 背景知识

HTML是万维网的核心标记语言。最初，HTML主要被设计用来语义化的表示科学文献的文档结构。然而，它出色的总体设计使的它能够在随后的几年里不断的调整适应来表示一些其它类型的文档甚至用来表示一些应用。

## 1.4 受众

这个规范适用于使用该规范定义的特性编写文档和脚本的作者。

因为这篇文档在有些地方为了准确性牺牲了清晰性，为了完整性牺牲了简洁，所以可能不适合对web技术不熟悉的读者。更容易理解的教程和实践指导才能够为那些web技术不熟悉的读者提供帮助。

特别当我们要理解规范中一些技术性比较强的地方，需要我们熟悉DOM的基础知识。了解Web IDL, HTTP, XML, character encodings, JavaScript, CSS也是有帮助的。

## 1.5 范围

这个规范仅仅提供一个标记语言的语义级别和相关的脚本APIs的语义级别，创作者可以利用这些APIs在web上创作从静态文档到动态应用程序的可访问页面。

这个规范的范围不包括媒体自定义的呈现机制（尽管浏览器默认的渲染规则被包括在该规范的末尾处，并且作为该语言的一部分提供了少量与CSS挂钩的机制）。

这个规范的范围不是去描述一个完整的操作的系统。特别是硬件配置软件，图像操作工具，和用户期望在高端工作站每天使用的应用程序都不在该规范的范围中。就应用程序而言，这个规范是专门针对于那些用户偶尔使用，或者经常使用但是来自不同位置，CPU需求较低的应用程序。这类应用程序的例子比如在线购买系统，搜索系统，游戏（尤其是多人在线游戏），公共电话簿和地址簿，通信软件（电子邮件客户端，即时消息客户端，讨论软件），文档编辑软件等等。


## 1.6 历史

在最初的五年里（1990-1995），HTML经历了许多修订和扩展，最初是在CERN，然后是在IETF。

伴随着W3C的创建，HTML的开发又一次改变了场所。1995年，HTML3.0作为第一次扩展HTML的尝试失败了，然后开发了更加实用的HTML3.2，在1997年的时候完成。HTML4在同一年迅速的跟进。

接下来的一年，W3C决定停止发展HTML，并且作为代替开始开发一种以XML为基础的技术，命名为XHTML。XHTML1.0始于用XML重新定义HTML4，它除了新的序列化并没有添加新的特性，于2000年完成。在XHTML1.0之后，W3C在XHTM模块化的思想引领下将重点转向如何使其他工作组更容易扩展XHTML。同期，W3C还开发了一种与早期的HTML和XHTML语言不兼容的新语言，命名为XHTML2。

大约在1998年HTML的发展停止的时候，浏览器供应商为HTML开发的一部分APIs被指定并且以DOM Level 1（在1998年）和DOM Level 2 Core以及DOM Level 2 HTML（在2000年开始，在2003年结束）的名称发布。这些努力后来逐渐消失了，伴随着在2004年一些DOM Level 3规范被发布，但是工作组在所有Level 3草案完成之前就关闭了。

在2003年，XForms作为一项被定义为下一代web表单的技术发布，激发了人们对发展HTML本身的兴趣，而不是寻找替代它的方法。这种兴趣源于这样一种认识，即XML作为web技术的部署仅限于全新的技术（如RSS和后来的Atom），而不是作为现有部署技术（HTML）的替代品。

一项被验证的概念是扩展HTML4的表单可以提供很多XForm1.0引入的新特性，而不需要浏览器实现与现有HTML web页面不兼容的呈现引擎，这是这种兴趣重燃的第一个结果。在这个早期阶段，虽然草案已经公开，并且已经从所有来源征求意见，但是这个规范仅受Opera Software的版权保护。

关于HTML应该继续得到发展的想法，在2004年W3C的一个研讨会上被提出。在研讨会上，关于HTML5工作的一些基本原则（如下所述）以及前面提到的只涉及表单相关特性的早期草案提案被Mozilla和Opera联合提交给了W3C。该提案被否决，理由是该提案与之前选择的web发展方向相冲突；W3C的工作人员和成员投票决定继续开发基于XML的替代品。

后来不久，Apple，Mozilla和Opera联合宣布，它们打算在一个被称为WHATWG的新场所下继续努力。一个公共邮件列表被创建，并且这个草案被移动到WHATWG站点。这个版权紧接着被修改为三家共同拥有并且允许重新使用这个规范。

这个WHATWG有一些核心原则，尤其是技术需要向后兼容，规范和实现需要相互匹配尽管有可能我们需要去改变规范而不是实现，并且规范需要描述的足够详细，这样实现就可以达到完全的互用性，从而不需要相互的反向工程。

后一个要求特别规定HTML5规范的范围包括之前在三个相互分离的文档中指定的内容：HTML4，XHTML和DOM2 HTML。它也意味着显然需要比以前被视为规范的内容包含更多的细节。

在2006年，W3C表示自己有兴趣参加HTML5的开发，并且在2007年成立了一个工作组和WHATWG一起开发HTML5规范。Apple，Mozilla和Opera允许W3C发布规范用W3C的版权，同时在WHATWG站点上用限制较少的许可证保留一个版本。

两个工作组在一起工作了一些年，到了2011年的时候，它们得出了它们拥有不同目标的结论：W3C想要去发布一个“HTML5”的“成品”版本，WHATWG则希望继续致力于HTML的生活标准，不断地维护规范而不是仅仅冻结在解决已知问题的状态，并且能够根据发展平台的需要去添加新的特性。

在2019年，WHATWG和W3C[签署了一项协议](https://www.w3.org/blog/news/archives/7753)，将合作开发单一版本的HTML: 就是这个文档。

## 1.7 设计说明

必须承认在HTML的很多方面第一眼看上去是无意义的和不一致的。

HTML，它支撑的DOM APIs，以及它支撑的许多技术，是由许多具有不同的人们在几十年的时间里开发出来的，它们在很多情况下并不知道彼此的存在。

因此特性有许多来源，而且并不总是以特别一致的方式进行设计。此外，由于web独特的特性，实现缺陷常常先成为事实上的标准，然后是规范上的标准，因此内容常常是在被修复之前以依赖它们的方式无意编写的。

尽管如此，人们还是努力坚持某些设计目标，将在下面几个小节中描述。

### 1.7.1 
为了避免web创作者暴露于多线程的复杂性，HTML和DOM API的设计使的没有脚本能够探测到其他脚本的同时执行。即使是workers, 它的目的也只想要实现的行为可以被认为在所有的浏览上下文中完全序列化的所有的脚本的执行。

这个通用设计原则的例外是JavaScript的ShareArrayBuffer类，用
ShareArrayBuffer类的对象可以观测到在其他代理中的正在同时执行的脚本。此外，由于JavaScript的内存模型，有些情况不仅通过序列化的脚本执行不能够表示，通过序列化在这些脚本中语句的执行也是不可表示的。

### 1.7.2 符合其他规范

这个规范与大量的其他规范相互作用并且依赖这些规范。不幸的是，在某些情况下，两者相互冲突的需求导致这个规范违反了其他规范的要求。每当这种请开给你发生的时候，每一次违规都被视为“故意违规”，违规的原因也会被记录。

### 1.7.3 扩展

HTML拥有大量的扩展机制被用来以一种安全的方式增加语义：

- 创作者能够用`class`属性去扩展元素，当使用最适用的现有的“真正的”HTML元素，能够有效的创建自己的元素，这样没有实现这个扩展的浏览器和其他工具能够仍然很好的支持它。例如，microformats采用这个方案。

- 创作者能够使用`data-*=""`属性存储数据为了内联的客户端脚本或者服务端站点范围的脚本去处理。这样能够确保浏览器不会接触到数据，并且允许脚本去拥有能够自己访问和处理的存储在HTML元素中的数据。

- 创作者能够使用`<meta name="" content="">`途径去表明页面范围的元数据。

- 创作者能够使用`rel=""`机制通过向预定义的连接类型集注册扩展给链接做特定意义的注解，microformats也采用了这种方法。

- 创作者能够使用自定义类型的`<script type="">`机制内嵌原生数据，用于客户端或者服务端脚本的进一步处理。

- 创作者能够创建`plugins`并且在`embed`元素中调用它们。这就是Flash的工作机制。

- 创作者能够使用JavaScript原型机制扩展APIs。这个方法已经在脚本库和实例中广泛使用。

- 创作者可以使用微数据特性（`itemscope=""`和`itemprop=""`属性）去嵌套名值对格式的数据，以便于和其他站点、应用程序共享。

## 1.8 HTML vs XML 语法

该规范定义了一种描述文档和应用的抽象语言，以及一些APIs用来和使用这个语言创作出的资源在内存中的表示进行交互。

这个在内存中的表示是被称为“DOM　HTML”，或者简称为“the DOM”。

这里有各种各样的语法能够帮助我们去传递使用这个抽象语言创作的资源，其中的两种在这个规范中被定义。

第一种是HTML语法。绝大多数创作者被建议使用这种格式。它与大多数传统的浏览器兼容。如果一个文档是用`text/html`MIME类型传输，然后它将被web浏览器作为HTML文档来处理。这个规范定义了最新的HTML语法，简单的被称为“HTML”。

第二种语法是XML。当一个文档是用XML MIME类型传输，例如`application/xhtml+xml`，然后它将被浏览器作为XML文档被一个XML解析器解析。需要提醒创作者的是针对XML和HTML处理的不同；尤其是尽管一些很小的错误，但是这将阻止浏览器完全渲染一个被标记为XML的文档，但是在HTML语法中它们很可能被忽略。

> HTML的XML语法以前被称作“XHTML”，但是这个规范并没有是有这个术语（原因之一是在MathML和SVG的HTML语法中没有使用这样的术语）。

DOM，HTML语法和XML语法并不能呈现相同的内容。例如，命名空间不能够用HTML语法呈现，但是他是可以被DOM和XML语法支持。类似的，使用`noscript`特性的文档能够用HTML语法呈现，但是不能够用DOM和XML语法呈现。包含字符串`"-->"`的注释只能在DOM中呈现，而不能被HTML和XHTML语法支持。

## 1.9 规范的组织

这个规范被划分为下面的几个主要章节：

**_介绍_**

为HTML标准提供一些非规范的上下文介绍材料

**_公共基础_**

一致性类，算法，定义，以及这个规范其余部分的公共基础

**_语义，结构，以及HTML文档的APIs_**

文档由元素构建。使用DOM把这些元素构建一棵树。本章节定义了DOM的特性，也介绍了所有元素的公共特性，以及与定义元素相关的概念。

**_HTML元素_**

每个元素都被赋予预先定义好的含义，本节将对此做出解释。还介绍了创作者如何去使用每个元素以及用户代理处理每个元素的要求。这包括了大量的签名特性，例如视频回放和字幕，表单控件和表单提交，以及一个被称作HTML canvas的2D图形API。

**_微数据_**

本章节介绍了一种给文档添加机器可读的注解的机制，这样工具就能从文档中抽离出名值对树。本章节描述了这种机制和一些能够将HTML文档转换成其他格式的算法。本章节也定义了一些用于联系信息，日历事件和授权工作的微数据词汇表示例。

**_用户交互_**

HTML为用户提供了大量的交互和修改内容的机制，这些机制在本章节被介绍，比如聚焦、拖放如何工作。

**_加载网页_**

HTML文档并不只与自己相关——这个章节定义了大量能够影响环境的特性，这些环境是处理多页面的环境，例如web浏览器。

**_web应用APIs_**

这个章节介绍了用HTML编写应用程序脚本的基本特性。

**_Web workers_**

本章节定义了一个利用JavaScript后台线程的API

**_Worklets_**

本章节定义了需要从主JavaScript执行环境分离出来执行的JavaScript的APIs的基础结构

**_通信APIs_**

这个章节描述了用HTML编写的应用可以用来与运行在同一客户端上的不同域的其他应用程序通信的一些机制。它也介绍了服务器推事件流机制被称作`Server Sent Events`或者`EventSource`，以及用于脚本的双向全双工套接字协议被称作`Web Sockets`。

**_网络存储_**

本章节定义了基于名值对的客户端存储机制

**_HTML语法_**

**_XML语法_**

如果不能以序列化的形式表示并且发送给其他人，那么所有的这些特性只是一文不值。这部分定义了HTML和XML的语法，以及如何利用这些语法来解析内容的规则。

**_渲染_**

本章节定义了浏览器的默认渲染规则。

还有一些附录，列出了废弃的特性和IAIA注意事项，以及少量的索引。


### 1.9.1 如何读这个规范

这个规范应该向所有其他规范一样被读。首先，要从头到尾读上好几遍。然后，应该反着读至少一遍。然后从目录中随机选取章节内容，并且跟着所有的参考链接来阅读。

正如下面的一致性要求的章节所描述的那样，这个规范为了各种一致性类描述了一致性标准。特别是，这儿有对于生产者的一致性要求，例如创作者和它们创作的文档，以及这儿有对于消费者的一致性要求，例如web浏览器。它们可以被区分通过它们被要求什么：对生产者的要求说明什么是允许的，对于消费者的要求表明软件是如何工作的。

> 例如，“这个`foo`属性的值必须是一个有效整数”是一个针对生产者的要求，因为它列出了被允许的值。相反，这个要求“这个`foo`属性的值必须用解析整数的规则进行解析”是针对消费者的，因为它描述了如何去处理内容。

**对生产者的要求对消费者没有任何影响**

继续上面的例子，一个表示一个特定属性的值被限制为有效整数的要求并没有暗示对消费者的任何要求。实际上，消费者可能需要将该属性视为不透明的字符串，完全不受值是否符合要求的影响。可能(如前面的例子所示)，消费者被要求去解析这个值用特定的规则，这个规则定义了如何处理无效(在本例中是非数字的)的值。

### 1.9.2 排版约定

这是一个定义，要求，或者解释。

<div style="background-color: green">这是一张便条</div>
---
<div style="background-color: grey">这是一个举例</div>
---
<div style="background-color: red">这是一条警告</div>
---
```
[Exposed = Window]
interface Example {
    //这是一条IDL定义
}
```
> variable = object.method([optionalArgument])
这是一张便条描述了接口的使用

<div style="background-color: yellow">这是一条CSS片段</div>

一条术语的定义实例是被标记成**this**, 使用这个术语是被标记成**this** 或者 **_this_**。
一个元素，属性或者API的定义实例是被标记成像<font color="red">this</font>。引用这个元素、属性或者API也被标记成
<font color="red">this</font>。
其他的代码片段被标记为灰色的。
变量被标记成为斜体细黑。
在一个算法中，同步代码段中的步骤是被标记成为 ⌛。
在一些情况下，要求是被用列表的形式给出，这些列表项表明一些条件和相应的要求。在这种情况下，适用于一个条件的要求总是在该条件之后的第一组要求，即使在这些要求有多个条件的情况下也是如此。下面是一个示例:

```
1.This is a condition
2.This is another condition
This is the requirement that applies to the conditions above.
3.This is a third condition
This is the requirement that applies to the third condition.
```

## 1.10 HTML的快速介绍

一个基础的HTML文档看起来像下面这样：
```
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Sample page</title>
  </head>
  <body>
    <h1>Sample page</h1>
    <p>This is a <a href="demo.html">Simple</a>Sample.</p>
    <!-- this is a comment -->
  </body>
</html>
```

HTML文档是由元素和文本组成的树结构。每个元素是被

















